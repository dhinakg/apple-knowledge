# typed: true

# DO NOT EDIT MANUALLY
# This is an autogenerated file for types exported from the `liquid` gem.
# Please instead update this file by running `bin/tapioca gem liquid`.

# source://liquid-4.0.3/lib/liquid/extensions.rb:16
class Array
  include ::Enumerable

  # source://liquid-4.0.3/lib/liquid/extensions.rb:17
  def to_liquid; end
end

# source://liquid-4.0.3/lib/liquid/extensions.rb:52
class Date
  include ::Comparable

  # source://liquid-4.0.3/lib/liquid/extensions.rb:53
  def to_liquid; end
end

# source://activesupport-7.0.3.1/lib/active_support/core_ext/date/conversions.rb:9
Date::DATE_FORMATS = T.let(T.unsafe(nil), Hash)

# source://RUBY_ROOT/date.rb:7
Date::VERSION = T.let(T.unsafe(nil), String)

# source://liquid-4.0.3/lib/liquid/extensions.rb:46
class DateTime < ::Date
  # source://liquid-4.0.3/lib/liquid/extensions.rb:47
  def to_liquid; end
end

# source://liquid-4.0.3/lib/liquid/extensions.rb:64
class FalseClass
  # source://liquid-4.0.3/lib/liquid/extensions.rb:65
  def to_liquid; end
end

# source://liquid-4.0.3/lib/liquid/extensions.rb:22
class Hash
  include ::Enumerable

  # source://liquid-4.0.3/lib/liquid/extensions.rb:23
  def to_liquid; end
end

# source://liquid-4.0.3/lib/liquid.rb:22
module Liquid
  class << self
    # source://liquid-4.0.3/lib/liquid.rb:43
    def cache_classes; end

    # source://liquid-4.0.3/lib/liquid.rb:43
    def cache_classes=(_arg0); end
  end
end

# source://liquid-4.0.3/lib/liquid.rb:38
Liquid::AnyStartingTag = T.let(T.unsafe(nil), Regexp)

# source://liquid-4.0.3/lib/liquid/errors.rb:41
class Liquid::ArgumentError < ::Liquid::Error; end

# source://liquid-4.0.3/lib/liquid.rb:24
Liquid::ArgumentSeparator = T.let(T.unsafe(nil), String)

# Assign sets a variable in your template.
#
#   {% assign foo = 'monkey' %}
#
# You can then use the variable later in the page.
#
#  {{ foo }}
#
# source://liquid-4.0.3/lib/liquid/tags/assign.rb:10
class Liquid::Assign < ::Liquid::Tag
  # @return [Assign] a new instance of Assign
  #
  # source://liquid-4.0.3/lib/liquid/tags/assign.rb:15
  def initialize(tag_name, markup, options); end

  # @return [Boolean]
  #
  # source://liquid-4.0.3/lib/liquid/tags/assign.rb:32
  def blank?; end

  # Returns the value of attribute from.
  #
  # source://liquid-4.0.3/lib/liquid/tags/assign.rb:13
  def from; end

  # source://liquid-4.0.3/lib/liquid/tags/assign.rb:25
  def render(context); end

  # Returns the value of attribute to.
  #
  # source://liquid-4.0.3/lib/liquid/tags/assign.rb:13
  def to; end

  private

  # source://liquid-4.0.3/lib/liquid/tags/assign.rb:38
  def assign_score_of(val); end
end

# source://liquid-4.0.3/lib/liquid/tags/assign.rb:51
class Liquid::Assign::ParseTreeVisitor < ::Liquid::ParseTreeVisitor
  # source://liquid-4.0.3/lib/liquid/tags/assign.rb:52
  def children; end
end

# source://liquid-4.0.3/lib/liquid/tags/assign.rb:11
Liquid::Assign::Syntax = T.let(T.unsafe(nil), Regexp)

# A Liquid file system is a way to let your templates retrieve other templates for use with the include tag.
#
# You can implement subclasses that retrieve templates from the database, from the file system using a different
# path structure, you can provide them as hard-coded inline strings, or any manner that you see fit.
#
# You can add additional instance variables, arguments, or methods as needed.
#
# Example:
#
#   Liquid::Template.file_system = Liquid::LocalFileSystem.new(template_path)
#   liquid = Liquid::Template.parse(template)
#
# This will parse the template with a LocalFileSystem implementation rooted at 'template_path'.
#
# source://liquid-4.0.3/lib/liquid/file_system.rb:15
class Liquid::BlankFileSystem
  # Called by Liquid to retrieve a template file
  #
  # @raise [FileSystemError]
  #
  # source://liquid-4.0.3/lib/liquid/file_system.rb:17
  def read_template_file(_template_path); end
end

# source://liquid-4.0.3/lib/liquid/block.rb:2
class Liquid::Block < ::Liquid::Tag
  # @return [Block] a new instance of Block
  #
  # source://liquid-4.0.3/lib/liquid/block.rb:5
  def initialize(tag_name, markup, options); end

  # @return [Boolean]
  #
  # source://liquid-4.0.3/lib/liquid/block.rb:20
  def blank?; end

  # source://liquid-4.0.3/lib/liquid/block.rb:46
  def block_delimiter; end

  # source://liquid-4.0.3/lib/liquid/block.rb:42
  def block_name; end

  # source://liquid-4.0.3/lib/liquid/block.rb:24
  def nodelist; end

  # source://liquid-4.0.3/lib/liquid/block.rb:10
  def parse(tokens); end

  # source://liquid-4.0.3/lib/liquid/block.rb:16
  def render(context); end

  # source://liquid-4.0.3/lib/liquid/block.rb:28
  def unknown_tag(tag, _params, _tokens); end

  protected

  # source://liquid-4.0.3/lib/liquid/block.rb:52
  def parse_body(body, tokens); end
end

# source://liquid-4.0.3/lib/liquid/block.rb:3
Liquid::Block::MAX_DEPTH = T.let(T.unsafe(nil), Integer)

# source://liquid-4.0.3/lib/liquid/block_body.rb:2
class Liquid::BlockBody
  # @return [BlockBody] a new instance of BlockBody
  #
  # source://liquid-4.0.3/lib/liquid/block_body.rb:11
  def initialize; end

  # @return [Boolean]
  #
  # source://liquid-4.0.3/lib/liquid/block_body.rb:65
  def blank?; end

  # Returns the value of attribute nodelist.
  #
  # source://liquid-4.0.3/lib/liquid/block_body.rb:9
  def nodelist; end

  # @yield [nil, nil]
  #
  # source://liquid-4.0.3/lib/liquid/block_body.rb:16
  def parse(tokenizer, parse_context); end

  # source://liquid-4.0.3/lib/liquid/block_body.rb:69
  def render(context); end

  # source://liquid-4.0.3/lib/liquid/block_body.rb:55
  def whitespace_handler(token, parse_context); end

  private

  # @raise [MemoryError]
  #
  # source://liquid-4.0.3/lib/liquid/block_body.rb:117
  def check_resources(context, node_output); end

  # source://liquid-4.0.3/lib/liquid/block_body.rb:123
  def create_variable(token, parse_context); end

  # @raise [SyntaxError]
  #
  # source://liquid-4.0.3/lib/liquid/block_body.rb:131
  def raise_missing_tag_terminator(token, parse_context); end

  # @raise [SyntaxError]
  #
  # source://liquid-4.0.3/lib/liquid/block_body.rb:135
  def raise_missing_variable_terminator(token, parse_context); end

  # source://liquid-4.0.3/lib/liquid/block_body.rb:139
  def registered_tags; end

  # source://liquid-4.0.3/lib/liquid/block_body.rb:102
  def render_node_to_output(node, output, context, skip_output = T.unsafe(nil)); end
end

# source://liquid-4.0.3/lib/liquid/block_body.rb:4
Liquid::BlockBody::ContentOfVariable = T.let(T.unsafe(nil), Regexp)

# source://liquid-4.0.3/lib/liquid/block_body.rb:3
Liquid::BlockBody::FullToken = T.let(T.unsafe(nil), Regexp)

# source://liquid-4.0.3/lib/liquid/block_body.rb:6
Liquid::BlockBody::TAGSTART = T.let(T.unsafe(nil), String)

# source://liquid-4.0.3/lib/liquid/block_body.rb:7
Liquid::BlockBody::VARSTART = T.let(T.unsafe(nil), String)

# source://liquid-4.0.3/lib/liquid/block_body.rb:5
Liquid::BlockBody::WhitespaceOrNothing = T.let(T.unsafe(nil), Regexp)

# Break tag to be used to break out of a for loop.
#
# == Basic Usage:
#    {% for item in collection %}
#      {% if item.condition %}
#        {% break %}
#      {% endif %}
#    {% endfor %}
#
# source://liquid-4.0.3/lib/liquid/tags/break.rb:11
class Liquid::Break < ::Liquid::Tag
  # source://liquid-4.0.3/lib/liquid/tags/break.rb:12
  def interrupt; end
end

# Interrupt that is thrown whenever a {% break %} is called.
#
# source://liquid-4.0.3/lib/liquid/interrupts.rb:12
class Liquid::BreakInterrupt < ::Liquid::Interrupt; end

# Capture stores the result of a block into a variable without rendering it inplace.
#
#   {% capture heading %}
#     Monkeys!
#   {% endcapture %}
#   ...
#   <h1>{{ heading }}</h1>
#
# Capture is useful for saving content for use later in your template, such as
# in a sidebar or footer.
#
# source://liquid-4.0.3/lib/liquid/tags/capture.rb:13
class Liquid::Capture < ::Liquid::Block
  # @return [Capture] a new instance of Capture
  #
  # source://liquid-4.0.3/lib/liquid/tags/capture.rb:16
  def initialize(tag_name, markup, options); end

  # @return [Boolean]
  #
  # source://liquid-4.0.3/lib/liquid/tags/capture.rb:32
  def blank?; end

  # source://liquid-4.0.3/lib/liquid/tags/capture.rb:25
  def render(context); end
end

# source://liquid-4.0.3/lib/liquid/tags/capture.rb:14
Liquid::Capture::Syntax = T.let(T.unsafe(nil), Regexp)

# source://liquid-4.0.3/lib/liquid/tags/case.rb:2
class Liquid::Case < ::Liquid::Block
  # @return [Case] a new instance of Case
  #
  # source://liquid-4.0.3/lib/liquid/tags/case.rb:8
  def initialize(tag_name, markup, options); end

  # Returns the value of attribute blocks.
  #
  # source://liquid-4.0.3/lib/liquid/tags/case.rb:6
  def blocks; end

  # Returns the value of attribute left.
  #
  # source://liquid-4.0.3/lib/liquid/tags/case.rb:6
  def left; end

  # source://liquid-4.0.3/lib/liquid/tags/case.rb:26
  def nodelist; end

  # source://liquid-4.0.3/lib/liquid/tags/case.rb:19
  def parse(tokens); end

  # source://liquid-4.0.3/lib/liquid/tags/case.rb:41
  def render(context); end

  # source://liquid-4.0.3/lib/liquid/tags/case.rb:30
  def unknown_tag(tag, markup, tokens); end

  private

  # source://liquid-4.0.3/lib/liquid/tags/case.rb:76
  def record_else_condition(markup); end

  # source://liquid-4.0.3/lib/liquid/tags/case.rb:60
  def record_when_condition(markup); end
end

# source://liquid-4.0.3/lib/liquid/tags/case.rb:86
class Liquid::Case::ParseTreeVisitor < ::Liquid::ParseTreeVisitor
  # source://liquid-4.0.3/lib/liquid/tags/case.rb:87
  def children; end
end

# source://liquid-4.0.3/lib/liquid/tags/case.rb:3
Liquid::Case::Syntax = T.let(T.unsafe(nil), Regexp)

# source://liquid-4.0.3/lib/liquid/tags/case.rb:4
Liquid::Case::WhenSyntax = T.let(T.unsafe(nil), Regexp)

# source://liquid-4.0.3/lib/liquid/tags/comment.rb:2
class Liquid::Comment < ::Liquid::Block
  # @return [Boolean]
  #
  # source://liquid-4.0.3/lib/liquid/tags/comment.rb:10
  def blank?; end

  # source://liquid-4.0.3/lib/liquid/tags/comment.rb:3
  def render(_context); end

  # source://liquid-4.0.3/lib/liquid/tags/comment.rb:7
  def unknown_tag(_tag, _markup, _tokens); end
end

# Container for liquid nodes which conveniently wraps decision making logic
#
# Example:
#
#   c = Condition.new(1, '==', 1)
#   c.evaluate #=> true
#
# source://liquid-4.0.3/lib/liquid/condition.rb:9
class Liquid::Condition
  # @return [Condition] a new instance of Condition
  #
  # source://liquid-4.0.3/lib/liquid/condition.rb:35
  def initialize(left = T.unsafe(nil), operator = T.unsafe(nil), right = T.unsafe(nil)); end

  # source://liquid-4.0.3/lib/liquid/condition.rb:67
  def and(condition); end

  # source://liquid-4.0.3/lib/liquid/condition.rb:72
  def attach(attachment); end

  # Returns the value of attribute attachment.
  #
  # source://liquid-4.0.3/lib/liquid/condition.rb:32
  def attachment; end

  # Returns the value of attribute child_condition.
  #
  # source://liquid-4.0.3/lib/liquid/condition.rb:32
  def child_condition; end

  # @return [Boolean]
  #
  # source://liquid-4.0.3/lib/liquid/condition.rb:76
  def else?; end

  # source://liquid-4.0.3/lib/liquid/condition.rb:43
  def evaluate(context = T.unsafe(nil)); end

  # source://liquid-4.0.3/lib/liquid/condition.rb:80
  def inspect; end

  # Returns the value of attribute left.
  #
  # source://liquid-4.0.3/lib/liquid/condition.rb:33
  def left; end

  # Sets the attribute left
  #
  # @param value the value to set the attribute left to.
  #
  # source://liquid-4.0.3/lib/liquid/condition.rb:33
  def left=(_arg0); end

  # Returns the value of attribute operator.
  #
  # source://liquid-4.0.3/lib/liquid/condition.rb:33
  def operator; end

  # Sets the attribute operator
  #
  # @param value the value to set the attribute operator to.
  #
  # source://liquid-4.0.3/lib/liquid/condition.rb:33
  def operator=(_arg0); end

  # source://liquid-4.0.3/lib/liquid/condition.rb:62
  def or(condition); end

  # Returns the value of attribute right.
  #
  # source://liquid-4.0.3/lib/liquid/condition.rb:33
  def right; end

  # Sets the attribute right
  #
  # @param value the value to set the attribute right to.
  #
  # source://liquid-4.0.3/lib/liquid/condition.rb:33
  def right=(_arg0); end

  protected

  # Returns the value of attribute child_relation.
  #
  # source://liquid-4.0.3/lib/liquid/condition.rb:86
  def child_relation; end

  private

  # source://liquid-4.0.3/lib/liquid/condition.rb:90
  def equal_variables(left, right); end

  # source://liquid-4.0.3/lib/liquid/condition.rb:110
  def interpret_condition(left, right, op, context); end

  class << self
    # source://liquid-4.0.3/lib/liquid/condition.rb:28
    def operators; end
  end
end

# source://liquid-4.0.3/lib/liquid/condition.rb:132
class Liquid::Condition::ParseTreeVisitor < ::Liquid::ParseTreeVisitor
  # source://liquid-4.0.3/lib/liquid/condition.rb:133
  def children; end
end

# Context keeps the variable stack and resolves variables, as well as keywords
#
#   context['variable'] = 'testing'
#   context['variable'] #=> 'testing'
#   context['true']     #=> true
#   context['10.2232']  #=> 10.2232
#
#   context.stack do
#      context['bob'] = 'bobsen'
#   end
#
#   context['bob']  #=> nil  class Context
#
# source://liquid-4.0.3/lib/liquid/context.rb:14
class Liquid::Context
  # @return [Context] a new instance of Context
  #
  # source://liquid-4.0.3/lib/liquid/context.rb:18
  def initialize(environments = T.unsafe(nil), outer_scope = T.unsafe(nil), registers = T.unsafe(nil), rethrow_errors = T.unsafe(nil), resource_limits = T.unsafe(nil)); end

  # Look up variable, either resolve directly after considering the name. We can directly handle
  # Strings, digits, floats and booleans (true,false).
  # If no match is made we lookup the variable in the current scope and
  # later move up to the parent blocks to see if we can resolve the variable somewhere up the tree.
  # Some special keywords return symbols. Those symbols are to be called on the rhs object in expressions
  #
  # Example:
  #   products == empty #=> products.empty?
  #
  # source://liquid-4.0.3/lib/liquid/context.rb:150
  def [](expression); end

  # Only allow String, Numeric, Hash, Array, Proc, Boolean or <tt>Liquid::Drop</tt>
  #
  # source://liquid-4.0.3/lib/liquid/context.rb:134
  def []=(key, value); end

  # Adds filters to this context.
  #
  # Note that this does not register the filters with the main Template object. see <tt>Template.register_filter</tt>
  # for that
  #
  # source://liquid-4.0.3/lib/liquid/context.rb:52
  def add_filters(filters); end

  # source://liquid-4.0.3/lib/liquid/context.rb:58
  def apply_global_filter(obj); end

  # source://liquid-4.0.3/lib/liquid/context.rb:129
  def clear_instance_assigns; end

  # Returns the value of attribute environments.
  #
  # source://liquid-4.0.3/lib/liquid/context.rb:15
  def environments; end

  # Returns the value of attribute errors.
  #
  # source://liquid-4.0.3/lib/liquid/context.rb:15
  def errors; end

  # source://liquid-4.0.3/lib/liquid/context.rb:158
  def evaluate(object); end

  # Returns the value of attribute exception_renderer.
  #
  # source://liquid-4.0.3/lib/liquid/context.rb:16
  def exception_renderer; end

  # Sets the attribute exception_renderer
  #
  # @param value the value to set the attribute exception_renderer to.
  #
  # source://liquid-4.0.3/lib/liquid/context.rb:16
  def exception_renderer=(_arg0); end

  # Fetches an object starting at the local scope and then moving up the hierachy
  #
  # source://liquid-4.0.3/lib/liquid/context.rb:163
  def find_variable(key, raise_on_not_found: T.unsafe(nil)); end

  # Returns the value of attribute global_filter.
  #
  # source://liquid-4.0.3/lib/liquid/context.rb:16
  def global_filter; end

  # Sets the attribute global_filter
  #
  # @param value the value to set the attribute global_filter to.
  #
  # source://liquid-4.0.3/lib/liquid/context.rb:16
  def global_filter=(_arg0); end

  # source://liquid-4.0.3/lib/liquid/context.rb:77
  def handle_error(e, line_number = T.unsafe(nil)); end

  # are there any not handled interrupts?
  #
  # @return [Boolean]
  #
  # source://liquid-4.0.3/lib/liquid/context.rb:63
  def interrupt?; end

  # source://liquid-4.0.3/lib/liquid/context.rb:85
  def invoke(method, *args); end

  # @return [Boolean]
  #
  # source://liquid-4.0.3/lib/liquid/context.rb:154
  def key?(key); end

  # source://liquid-4.0.3/lib/liquid/context.rb:192
  def lookup_and_evaluate(obj, key, raise_on_not_found: T.unsafe(nil)); end

  # Merge a hash of variables in the current local scope
  #
  # source://liquid-4.0.3/lib/liquid/context.rb:96
  def merge(new_scopes); end

  # Returns the value of attribute partial.
  #
  # source://liquid-4.0.3/lib/liquid/context.rb:16
  def partial; end

  # Sets the attribute partial
  #
  # @param value the value to set the attribute partial to.
  #
  # source://liquid-4.0.3/lib/liquid/context.rb:16
  def partial=(_arg0); end

  # Pop from the stack. use <tt>Context#stack</tt> instead
  #
  # @raise [ContextError]
  #
  # source://liquid-4.0.3/lib/liquid/context.rb:101
  def pop; end

  # pop an interrupt from the stack
  #
  # source://liquid-4.0.3/lib/liquid/context.rb:73
  def pop_interrupt; end

  # Push new local scope on the stack. use <tt>Context#stack</tt> instead
  #
  # @raise [StackLevelError]
  #
  # source://liquid-4.0.3/lib/liquid/context.rb:90
  def push(new_scope = T.unsafe(nil)); end

  # push an interrupt to the stack. this interrupt is considered not handled.
  #
  # source://liquid-4.0.3/lib/liquid/context.rb:68
  def push_interrupt(e); end

  # Returns the value of attribute registers.
  #
  # source://liquid-4.0.3/lib/liquid/context.rb:15
  def registers; end

  # Returns the value of attribute resource_limits.
  #
  # source://liquid-4.0.3/lib/liquid/context.rb:15
  def resource_limits; end

  # Returns the value of attribute scopes.
  #
  # source://liquid-4.0.3/lib/liquid/context.rb:15
  def scopes; end

  # Pushes a new local scope on the stack, pops it at the end of the block
  #
  # Example:
  #   context.stack do
  #      context['var'] = 'hi'
  #   end
  #
  #   context['var]  #=> nil
  #
  # source://liquid-4.0.3/lib/liquid/context.rb:114
  def stack(new_scope = T.unsafe(nil)); end

  # source://liquid-4.0.3/lib/liquid/context.rb:44
  def strainer; end

  # Returns the value of attribute strict_filters.
  #
  # source://liquid-4.0.3/lib/liquid/context.rb:16
  def strict_filters; end

  # Sets the attribute strict_filters
  #
  # @param value the value to set the attribute strict_filters to.
  #
  # source://liquid-4.0.3/lib/liquid/context.rb:16
  def strict_filters=(_arg0); end

  # Returns the value of attribute strict_variables.
  #
  # source://liquid-4.0.3/lib/liquid/context.rb:16
  def strict_variables; end

  # Sets the attribute strict_variables
  #
  # @param value the value to set the attribute strict_variables to.
  #
  # source://liquid-4.0.3/lib/liquid/context.rb:16
  def strict_variables=(_arg0); end

  # Returns the value of attribute template_name.
  #
  # source://liquid-4.0.3/lib/liquid/context.rb:16
  def template_name; end

  # Sets the attribute template_name
  #
  # @param value the value to set the attribute template_name to.
  #
  # source://liquid-4.0.3/lib/liquid/context.rb:16
  def template_name=(_arg0); end

  # source://liquid-4.0.3/lib/liquid/context.rb:40
  def warnings; end

  private

  # source://liquid-4.0.3/lib/liquid/context.rb:208
  def internal_error; end

  # source://liquid-4.0.3/lib/liquid/context.rb:215
  def squash_instance_assigns_with_environments; end
end

# source://liquid-4.0.3/lib/liquid/errors.rb:42
class Liquid::ContextError < ::Liquid::Error; end

# Continue tag to be used to break out of a for loop.
#
# == Basic Usage:
#    {% for item in collection %}
#      {% if item.condition %}
#        {% continue %}
#      {% endif %}
#    {% endfor %}
#
# source://liquid-4.0.3/lib/liquid/tags/continue.rb:11
class Liquid::Continue < ::Liquid::Tag
  # source://liquid-4.0.3/lib/liquid/tags/continue.rb:12
  def interrupt; end
end

# Interrupt that is thrown whenever a {% continue %} is called.
#
# source://liquid-4.0.3/lib/liquid/interrupts.rb:15
class Liquid::ContinueInterrupt < ::Liquid::Interrupt; end

# Cycle is usually used within a loop to alternate between values, like colors or DOM classes.
#
#   {% for item in items %}
#     <div class="{% cycle 'red', 'green', 'blue' %}"> {{ item }} </div>
#   {% end %}
#
#    <div class="red"> Item one </div>
#    <div class="green"> Item two </div>
#    <div class="blue"> Item three </div>
#    <div class="red"> Item four </div>
#    <div class="green"> Item five</div>
#
# source://liquid-4.0.3/lib/liquid/tags/cycle.rb:14
class Liquid::Cycle < ::Liquid::Tag
  # @return [Cycle] a new instance of Cycle
  #
  # source://liquid-4.0.3/lib/liquid/tags/cycle.rb:20
  def initialize(tag_name, markup, options); end

  # source://liquid-4.0.3/lib/liquid/tags/cycle.rb:34
  def render(context); end

  # Returns the value of attribute variables.
  #
  # source://liquid-4.0.3/lib/liquid/tags/cycle.rb:18
  def variables; end

  private

  # source://liquid-4.0.3/lib/liquid/tags/cycle.rb:50
  def variables_from_string(markup); end
end

# source://liquid-4.0.3/lib/liquid/tags/cycle.rb:16
Liquid::Cycle::NamedSyntax = T.let(T.unsafe(nil), Regexp)

# source://liquid-4.0.3/lib/liquid/tags/cycle.rb:57
class Liquid::Cycle::ParseTreeVisitor < ::Liquid::ParseTreeVisitor
  # source://liquid-4.0.3/lib/liquid/tags/cycle.rb:58
  def children; end
end

# source://liquid-4.0.3/lib/liquid/tags/cycle.rb:15
Liquid::Cycle::SimpleSyntax = T.let(T.unsafe(nil), Regexp)

# Hello: {% decrement variable %}
#
# gives you:
#
#    Hello: -1
#    Hello: -2
#    Hello: -3
#
# source://liquid-4.0.3/lib/liquid/tags/decrement.rb:20
class Liquid::Decrement < ::Liquid::Tag
  # @return [Decrement] a new instance of Decrement
  #
  # source://liquid-4.0.3/lib/liquid/tags/decrement.rb:21
  def initialize(tag_name, markup, options); end

  # source://liquid-4.0.3/lib/liquid/tags/decrement.rb:26
  def render(context); end
end

# source://liquid-4.0.3/lib/liquid/document.rb:2
class Liquid::Document < ::Liquid::BlockBody
  # source://liquid-4.0.3/lib/liquid/document.rb:9
  def parse(tokens, parse_context); end

  # source://liquid-4.0.3/lib/liquid/document.rb:18
  def unknown_tag(tag, parse_context); end

  class << self
    # source://liquid-4.0.3/lib/liquid/document.rb:3
    def parse(tokens, parse_context); end
  end
end

# A drop in liquid is a class which allows you to export DOM like things to liquid.
# Methods of drops are callable.
# The main use for liquid drops is to implement lazy loaded objects.
# If you would like to make data available to the web designers which you don't want loaded unless needed then
# a drop is a great way to do that.
#
# Example:
#
#   class ProductDrop < Liquid::Drop
#     def top_sales
#       Shop.current.products.find(:all, :order => 'sales', :limit => 10 )
#     end
#   end
#
#   tmpl = Liquid::Template.parse( ' {% for product in product.top_sales %} {{ product.name }} {%endfor%} '  )
#   tmpl.render('product' => ProductDrop.new ) # will invoke top_sales query.
#
# Your drop can either implement the methods sans any parameters
# or implement the liquid_method_missing(name) method which is a catch all.
#
# source://liquid-4.0.3/lib/liquid/drop.rb:23
class Liquid::Drop
  # called by liquid to invoke a drop
  #
  # source://liquid-4.0.3/lib/liquid/drop.rb:33
  def [](method_or_key); end

  # Sets the attribute context
  #
  # @param value the value to set the attribute context to.
  #
  # source://liquid-4.0.3/lib/liquid/drop.rb:24
  def context=(_arg0); end

  # source://liquid-4.0.3/lib/liquid/drop.rb:45
  def inspect; end

  # called by liquid to invoke a drop
  #
  # source://liquid-4.0.3/lib/liquid/drop.rb:33
  def invoke_drop(method_or_key); end

  # @return [Boolean]
  #
  # source://liquid-4.0.3/lib/liquid/drop.rb:41
  def key?(_name); end

  # Catch all for the method
  #
  # @raise [Liquid::UndefinedDropMethod]
  #
  # source://liquid-4.0.3/lib/liquid/drop.rb:27
  def liquid_method_missing(method); end

  # source://liquid-4.0.3/lib/liquid/drop.rb:49
  def to_liquid; end

  # source://liquid-4.0.3/lib/liquid/drop.rb:53
  def to_s; end

  class << self
    # Check for method existence without invoking respond_to?, which creates symbols
    #
    # @return [Boolean]
    #
    # source://liquid-4.0.3/lib/liquid/drop.rb:60
    def invokable?(method_name); end

    # source://liquid-4.0.3/lib/liquid/drop.rb:64
    def invokable_methods; end
  end
end

# source://liquid-4.0.3/lib/liquid/condition.rb:142
class Liquid::ElseCondition < ::Liquid::Condition
  # @return [Boolean]
  #
  # source://liquid-4.0.3/lib/liquid/condition.rb:143
  def else?; end

  # source://liquid-4.0.3/lib/liquid/condition.rb:147
  def evaluate(_context); end
end

# source://liquid-4.0.3/lib/liquid/errors.rb:2
class Liquid::Error < ::StandardError
  # Returns the value of attribute line_number.
  #
  # source://liquid-4.0.3/lib/liquid/errors.rb:3
  def line_number; end

  # Sets the attribute line_number
  #
  # @param value the value to set the attribute line_number to.
  #
  # source://liquid-4.0.3/lib/liquid/errors.rb:3
  def line_number=(_arg0); end

  # Returns the value of attribute markup_context.
  #
  # source://liquid-4.0.3/lib/liquid/errors.rb:5
  def markup_context; end

  # Sets the attribute markup_context
  #
  # @param value the value to set the attribute markup_context to.
  #
  # source://liquid-4.0.3/lib/liquid/errors.rb:5
  def markup_context=(_arg0); end

  # Returns the value of attribute template_name.
  #
  # source://liquid-4.0.3/lib/liquid/errors.rb:4
  def template_name; end

  # Sets the attribute template_name
  #
  # @param value the value to set the attribute template_name to.
  #
  # source://liquid-4.0.3/lib/liquid/errors.rb:4
  def template_name=(_arg0); end

  # source://liquid-4.0.3/lib/liquid/errors.rb:7
  def to_s(with_prefix = T.unsafe(nil)); end

  private

  # source://liquid-4.0.3/lib/liquid/errors.rb:22
  def message_prefix; end
end

# source://liquid-4.0.3/lib/liquid/expression.rb:2
class Liquid::Expression
  class << self
    # source://liquid-4.0.3/lib/liquid/expression.rb:30
    def parse(markup); end
  end
end

# source://liquid-4.0.3/lib/liquid/expression.rb:25
Liquid::Expression::DOUBLE_QUOTED_STRING = T.let(T.unsafe(nil), Regexp)

# source://liquid-4.0.3/lib/liquid/expression.rb:27
Liquid::Expression::FLOATS_REGEX = T.let(T.unsafe(nil), Regexp)

# source://liquid-4.0.3/lib/liquid/expression.rb:26
Liquid::Expression::INTEGERS_REGEX = T.let(T.unsafe(nil), Regexp)

# source://liquid-4.0.3/lib/liquid/expression.rb:16
Liquid::Expression::LITERALS = T.let(T.unsafe(nil), Hash)

# source://liquid-4.0.3/lib/liquid/expression.rb:3
class Liquid::Expression::MethodLiteral
  # @return [MethodLiteral] a new instance of MethodLiteral
  #
  # source://liquid-4.0.3/lib/liquid/expression.rb:6
  def initialize(method_name, to_s); end

  # Returns the value of attribute method_name.
  #
  # source://liquid-4.0.3/lib/liquid/expression.rb:4
  def method_name; end

  # source://liquid-4.0.3/lib/liquid/expression.rb:11
  def to_liquid; end

  # Returns the value of attribute to_s.
  #
  # source://liquid-4.0.3/lib/liquid/expression.rb:4
  def to_s; end
end

# source://liquid-4.0.3/lib/liquid/expression.rb:28
Liquid::Expression::RANGES_REGEX = T.let(T.unsafe(nil), Regexp)

# source://liquid-4.0.3/lib/liquid/expression.rb:24
Liquid::Expression::SINGLE_QUOTED_STRING = T.let(T.unsafe(nil), Regexp)

# source://liquid-4.0.3/lib/liquid/errors.rb:43
class Liquid::FileSystemError < ::Liquid::Error; end

# source://liquid-4.0.3/lib/liquid.rb:25
Liquid::FilterArgumentSeparator = T.let(T.unsafe(nil), String)

# source://liquid-4.0.3/lib/liquid.rb:23
Liquid::FilterSeparator = T.let(T.unsafe(nil), Regexp)

# source://liquid-4.0.3/lib/liquid/errors.rb:50
class Liquid::FloatDomainError < ::Liquid::Error; end

# "For" iterates over an array or collection.
# Several useful variables are available to you within the loop.
#
# == Basic usage:
#    {% for item in collection %}
#      {{ forloop.index }}: {{ item.name }}
#    {% endfor %}
#
# == Advanced usage:
#    {% for item in collection %}
#      <div {% if forloop.first %}class="first"{% endif %}>
#        Item {{ forloop.index }}: {{ item.name }}
#      </div>
#    {% else %}
#      There is nothing in the collection.
#    {% endfor %}
#
# You can also define a limit and offset much like SQL.  Remember
# that offset starts at 0 for the first item.
#
#    {% for item in collection limit:5 offset:10 %}
#      {{ item.name }}
#    {% end %}
#
#  To reverse the for loop simply use {% for item in collection reversed %} (note that the flag's spelling is different to the filter `reverse`)
#
# == Available variables:
#
# forloop.name:: 'item-collection'
# forloop.length:: Length of the loop
# forloop.index:: The current item's position in the collection;
#                 forloop.index starts at 1.
#                 This is helpful for non-programmers who start believe
#                 the first item in an array is 1, not 0.
# forloop.index0:: The current item's position in the collection
#                  where the first item is 0
# forloop.rindex:: Number of items remaining in the loop
#                  (length - index) where 1 is the last item.
# forloop.rindex0:: Number of items remaining in the loop
#                   where 0 is the last item.
# forloop.first:: Returns true if the item is the first item.
# forloop.last:: Returns true if the item is the last item.
# forloop.parentloop:: Provides access to the parent loop, if present.
#
# source://liquid-4.0.3/lib/liquid/tags/for.rb:46
class Liquid::For < ::Liquid::Block
  # @return [For] a new instance of For
  #
  # source://liquid-4.0.3/lib/liquid/tags/for.rb:51
  def initialize(tag_name, markup, options); end

  # Returns the value of attribute collection_name.
  #
  # source://liquid-4.0.3/lib/liquid/tags/for.rb:49
  def collection_name; end

  # Returns the value of attribute from.
  #
  # source://liquid-4.0.3/lib/liquid/tags/for.rb:49
  def from; end

  # Returns the value of attribute limit.
  #
  # source://liquid-4.0.3/lib/liquid/tags/for.rb:49
  def limit; end

  # source://liquid-4.0.3/lib/liquid/tags/for.rb:64
  def nodelist; end

  # source://liquid-4.0.3/lib/liquid/tags/for.rb:59
  def parse(tokens); end

  # source://liquid-4.0.3/lib/liquid/tags/for.rb:73
  def render(context); end

  # source://liquid-4.0.3/lib/liquid/tags/for.rb:68
  def unknown_tag(tag, markup, tokens); end

  # Returns the value of attribute variable_name.
  #
  # source://liquid-4.0.3/lib/liquid/tags/for.rb:49
  def variable_name; end

  protected

  # source://liquid-4.0.3/lib/liquid/tags/for.rb:85
  def lax_parse(markup); end

  # @raise [SyntaxError]
  #
  # source://liquid-4.0.3/lib/liquid/tags/for.rb:100
  def strict_parse(markup); end

  private

  # source://liquid-4.0.3/lib/liquid/tags/for.rb:121
  def collection_segment(context); end

  # source://liquid-4.0.3/lib/liquid/tags/for.rb:191
  def render_else(context); end

  # source://liquid-4.0.3/lib/liquid/tags/for.rb:144
  def render_segment(context, segment); end

  # source://liquid-4.0.3/lib/liquid/tags/for.rb:178
  def set_attribute(key, expr); end
end

# source://liquid-4.0.3/lib/liquid/tags/for.rb:195
class Liquid::For::ParseTreeVisitor < ::Liquid::ParseTreeVisitor
  # source://liquid-4.0.3/lib/liquid/tags/for.rb:196
  def children; end
end

# source://liquid-4.0.3/lib/liquid/tags/for.rb:47
Liquid::For::Syntax = T.let(T.unsafe(nil), Regexp)

# source://liquid-4.0.3/lib/liquid/forloop_drop.rb:2
class Liquid::ForloopDrop < ::Liquid::Drop
  # @return [ForloopDrop] a new instance of ForloopDrop
  #
  # source://liquid-4.0.3/lib/liquid/forloop_drop.rb:3
  def initialize(name, length, parentloop); end

  # source://liquid-4.0.3/lib/liquid/forloop_drop.rb:28
  def first; end

  # source://liquid-4.0.3/lib/liquid/forloop_drop.rb:12
  def index; end

  # source://liquid-4.0.3/lib/liquid/forloop_drop.rb:16
  def index0; end

  # source://liquid-4.0.3/lib/liquid/forloop_drop.rb:32
  def last; end

  # Returns the value of attribute length.
  #
  # source://liquid-4.0.3/lib/liquid/forloop_drop.rb:10
  def length; end

  # Returns the value of attribute name.
  #
  # source://liquid-4.0.3/lib/liquid/forloop_drop.rb:10
  def name; end

  # Returns the value of attribute parentloop.
  #
  # source://liquid-4.0.3/lib/liquid/forloop_drop.rb:10
  def parentloop; end

  # source://liquid-4.0.3/lib/liquid/forloop_drop.rb:20
  def rindex; end

  # source://liquid-4.0.3/lib/liquid/forloop_drop.rb:24
  def rindex0; end

  protected

  # source://liquid-4.0.3/lib/liquid/forloop_drop.rb:38
  def increment!; end
end

# source://liquid-4.0.3/lib/liquid/i18n.rb:4
class Liquid::I18n
  # @return [I18n] a new instance of I18n
  #
  # source://liquid-4.0.3/lib/liquid/i18n.rb:11
  def initialize(path = T.unsafe(nil)); end

  # source://liquid-4.0.3/lib/liquid/i18n.rb:20
  def locale; end

  # Returns the value of attribute path.
  #
  # source://liquid-4.0.3/lib/liquid/i18n.rb:9
  def path; end

  # source://liquid-4.0.3/lib/liquid/i18n.rb:15
  def t(name, vars = T.unsafe(nil)); end

  # source://liquid-4.0.3/lib/liquid/i18n.rb:15
  def translate(name, vars = T.unsafe(nil)); end

  private

  # source://liquid-4.0.3/lib/liquid/i18n.rb:33
  def deep_fetch_translation(name); end

  # source://liquid-4.0.3/lib/liquid/i18n.rb:26
  def interpolate(name, vars); end
end

# source://liquid-4.0.3/lib/liquid/i18n.rb:5
Liquid::I18n::DEFAULT_LOCALE = T.let(T.unsafe(nil), String)

# source://liquid-4.0.3/lib/liquid/i18n.rb:7
class Liquid::I18n::TranslationError < ::StandardError; end

# If is the conditional block
#
#   {% if user.admin %}
#     Admin user!
#   {% else %}
#     Not admin user
#   {% endif %}
#
#    There are {% if count < 5 %} less {% else %} more {% endif %} items than you need.
#
# source://liquid-4.0.3/lib/liquid/tags/if.rb:12
class Liquid::If < ::Liquid::Block
  # @return [If] a new instance of If
  #
  # source://liquid-4.0.3/lib/liquid/tags/if.rb:19
  def initialize(tag_name, markup, options); end

  # Returns the value of attribute blocks.
  #
  # source://liquid-4.0.3/lib/liquid/tags/if.rb:17
  def blocks; end

  # source://liquid-4.0.3/lib/liquid/tags/if.rb:25
  def nodelist; end

  # source://liquid-4.0.3/lib/liquid/tags/if.rb:29
  def parse(tokens); end

  # source://liquid-4.0.3/lib/liquid/tags/if.rb:42
  def render(context); end

  # source://liquid-4.0.3/lib/liquid/tags/if.rb:34
  def unknown_tag(tag, markup, tokens); end

  private

  # @raise [SyntaxError]
  #
  # source://liquid-4.0.3/lib/liquid/tags/if.rb:66
  def lax_parse(markup); end

  # source://liquid-4.0.3/lib/liquid/tags/if.rb:93
  def parse_binary_comparisons(p); end

  # source://liquid-4.0.3/lib/liquid/tags/if.rb:104
  def parse_comparison(p); end

  # source://liquid-4.0.3/lib/liquid/tags/if.rb:55
  def push_block(tag, markup); end

  # source://liquid-4.0.3/lib/liquid/tags/if.rb:86
  def strict_parse(markup); end
end

# source://liquid-4.0.3/lib/liquid/tags/if.rb:15
Liquid::If::BOOLEAN_OPERATORS = T.let(T.unsafe(nil), Array)

# source://liquid-4.0.3/lib/liquid/tags/if.rb:14
Liquid::If::ExpressionsAndOperators = T.let(T.unsafe(nil), Regexp)

# source://liquid-4.0.3/lib/liquid/tags/if.rb:114
class Liquid::If::ParseTreeVisitor < ::Liquid::ParseTreeVisitor
  # source://liquid-4.0.3/lib/liquid/tags/if.rb:115
  def children; end
end

# source://liquid-4.0.3/lib/liquid/tags/if.rb:13
Liquid::If::Syntax = T.let(T.unsafe(nil), Regexp)

# source://liquid-4.0.3/lib/liquid/tags/ifchanged.rb:2
class Liquid::Ifchanged < ::Liquid::Block
  # source://liquid-4.0.3/lib/liquid/tags/ifchanged.rb:3
  def render(context); end
end

# Include allows templates to relate with other templates
#
# Simply include another template:
#
#   {% include 'product' %}
#
# Include a template with a local variable:
#
#   {% include 'product' with products[0] %}
#
# Include a template for a collection:
#
#   {% include 'product' for products %}
#
# source://liquid-4.0.3/lib/liquid/tags/include.rb:16
class Liquid::Include < ::Liquid::Tag
  # @return [Include] a new instance of Include
  #
  # source://liquid-4.0.3/lib/liquid/tags/include.rb:21
  def initialize(tag_name, markup, options); end

  # Returns the value of attribute attributes.
  #
  # source://liquid-4.0.3/lib/liquid/tags/include.rb:19
  def attributes; end

  # source://liquid-4.0.3/lib/liquid/tags/include.rb:42
  def parse(_tokens); end

  # @raise [ArgumentError]
  #
  # source://liquid-4.0.3/lib/liquid/tags/include.rb:45
  def render(context); end

  # Returns the value of attribute template_name_expr.
  #
  # source://liquid-4.0.3/lib/liquid/tags/include.rb:19
  def template_name_expr; end

  # Returns the value of attribute variable_name_expr.
  #
  # source://liquid-4.0.3/lib/liquid/tags/include.rb:19
  def variable_name_expr; end

  private

  # source://liquid-4.0.3/lib/liquid/tags/include.rb:89
  def load_cached_partial(template_name, context); end

  # source://liquid-4.0.3/lib/liquid/tag.rb:3
  def parse_context; end

  # source://liquid-4.0.3/lib/liquid/tags/include.rb:107
  def read_template_from_file_system(context); end
end

# source://liquid-4.0.3/lib/liquid/tags/include.rb:113
class Liquid::Include::ParseTreeVisitor < ::Liquid::ParseTreeVisitor
  # source://liquid-4.0.3/lib/liquid/tags/include.rb:114
  def children; end
end

# source://liquid-4.0.3/lib/liquid/tags/include.rb:17
Liquid::Include::Syntax = T.let(T.unsafe(nil), Regexp)

# increment is used in a place where one needs to insert a counter
#     into a template, and needs the counter to survive across
#     multiple instantiations of the template.
#     (To achieve the survival, the application must keep the context)
#
#     if the variable does not exist, it is created with value 0.
#
#   Hello: {% increment variable %}
#
# gives you:
#
#    Hello: 0
#    Hello: 1
#    Hello: 2
#
# source://liquid-4.0.3/lib/liquid/tags/increment.rb:17
class Liquid::Increment < ::Liquid::Tag
  # @return [Increment] a new instance of Increment
  #
  # source://liquid-4.0.3/lib/liquid/tags/increment.rb:18
  def initialize(tag_name, markup, options); end

  # source://liquid-4.0.3/lib/liquid/tags/increment.rb:23
  def render(context); end
end

# source://liquid-4.0.3/lib/liquid/errors.rb:55
class Liquid::InternalError < ::Liquid::Error; end

# An interrupt is any command that breaks processing of a block (ex: a for loop).
#
# source://liquid-4.0.3/lib/liquid/interrupts.rb:3
class Liquid::Interrupt
  # @return [Interrupt] a new instance of Interrupt
  #
  # source://liquid-4.0.3/lib/liquid/interrupts.rb:6
  def initialize(message = T.unsafe(nil)); end

  # Returns the value of attribute message.
  #
  # source://liquid-4.0.3/lib/liquid/interrupts.rb:4
  def message; end
end

# source://liquid-4.0.3/lib/liquid/lexer.rb:3
class Liquid::Lexer
  # @return [Lexer] a new instance of Lexer
  #
  # source://liquid-4.0.3/lib/liquid/lexer.rb:24
  def initialize(input); end

  # source://liquid-4.0.3/lib/liquid/lexer.rb:28
  def tokenize; end
end

# source://liquid-4.0.3/lib/liquid/lexer.rb:21
Liquid::Lexer::COMPARISON_OPERATOR = T.let(T.unsafe(nil), Regexp)

# source://liquid-4.0.3/lib/liquid/lexer.rb:20
Liquid::Lexer::DOTDOT = T.let(T.unsafe(nil), Regexp)

# source://liquid-4.0.3/lib/liquid/lexer.rb:18
Liquid::Lexer::DOUBLE_STRING_LITERAL = T.let(T.unsafe(nil), Regexp)

# source://liquid-4.0.3/lib/liquid/lexer.rb:16
Liquid::Lexer::IDENTIFIER = T.let(T.unsafe(nil), Regexp)

# source://liquid-4.0.3/lib/liquid/lexer.rb:19
Liquid::Lexer::NUMBER_LITERAL = T.let(T.unsafe(nil), Regexp)

# source://liquid-4.0.3/lib/liquid/lexer.rb:17
Liquid::Lexer::SINGLE_STRING_LITERAL = T.let(T.unsafe(nil), Regexp)

# source://liquid-4.0.3/lib/liquid/lexer.rb:4
Liquid::Lexer::SPECIALS = T.let(T.unsafe(nil), Hash)

# source://liquid-4.0.3/lib/liquid/lexer.rb:22
Liquid::Lexer::WHITESPACE_OR_NOTHING = T.let(T.unsafe(nil), Regexp)

# This implements an abstract file system which retrieves template files named in a manner similar to Rails partials,
# ie. with the template name prefixed with an underscore. The extension ".liquid" is also added.
#
# For security reasons, template paths are only allowed to contain letters, numbers, and underscore.
#
# Example:
#
#   file_system = Liquid::LocalFileSystem.new("/some/path")
#
#   file_system.full_path("mypartial")       # => "/some/path/_mypartial.liquid"
#   file_system.full_path("dir/mypartial")   # => "/some/path/dir/_mypartial.liquid"
#
# Optionally in the second argument you can specify a custom pattern for template filenames.
# The Kernel::sprintf format specification is used.
# Default pattern is "_%s.liquid".
#
# Example:
#
#   file_system = Liquid::LocalFileSystem.new("/some/path", "%s.html")
#
#   file_system.full_path("index") # => "/some/path/index.html"
#
# source://liquid-4.0.3/lib/liquid/file_system.rb:44
class Liquid::LocalFileSystem
  # @return [LocalFileSystem] a new instance of LocalFileSystem
  #
  # source://liquid-4.0.3/lib/liquid/file_system.rb:47
  def initialize(root, pattern = T.unsafe(nil)); end

  # @raise [FileSystemError]
  #
  # source://liquid-4.0.3/lib/liquid/file_system.rb:59
  def full_path(template_path); end

  # @raise [FileSystemError]
  #
  # source://liquid-4.0.3/lib/liquid/file_system.rb:52
  def read_template_file(template_path); end

  # Returns the value of attribute root.
  #
  # source://liquid-4.0.3/lib/liquid/file_system.rb:45
  def root; end

  # Sets the attribute root
  #
  # @param value the value to set the attribute root to.
  #
  # source://liquid-4.0.3/lib/liquid/file_system.rb:45
  def root=(_arg0); end
end

# source://liquid-4.0.3/lib/liquid/errors.rb:48
class Liquid::MemoryError < ::Liquid::Error; end

# source://liquid-4.0.3/lib/liquid/errors.rb:54
class Liquid::MethodOverrideError < ::Liquid::Error; end

# source://liquid-4.0.3/lib/liquid/parse_context.rb:2
class Liquid::ParseContext
  # @return [ParseContext] a new instance of ParseContext
  #
  # source://liquid-4.0.3/lib/liquid/parse_context.rb:6
  def initialize(options = T.unsafe(nil)); end

  # source://liquid-4.0.3/lib/liquid/parse_context.rb:14
  def [](option_key); end

  # Returns the value of attribute depth.
  #
  # source://liquid-4.0.3/lib/liquid/parse_context.rb:3
  def depth; end

  # Sets the attribute depth
  #
  # @param value the value to set the attribute depth to.
  #
  # source://liquid-4.0.3/lib/liquid/parse_context.rb:3
  def depth=(_arg0); end

  # Returns the value of attribute error_mode.
  #
  # source://liquid-4.0.3/lib/liquid/parse_context.rb:4
  def error_mode; end

  # Returns the value of attribute line_number.
  #
  # source://liquid-4.0.3/lib/liquid/parse_context.rb:3
  def line_number; end

  # Sets the attribute line_number
  #
  # @param value the value to set the attribute line_number to.
  #
  # source://liquid-4.0.3/lib/liquid/parse_context.rb:3
  def line_number=(_arg0); end

  # Returns the value of attribute locale.
  #
  # source://liquid-4.0.3/lib/liquid/parse_context.rb:3
  def locale; end

  # Sets the attribute locale
  #
  # @param value the value to set the attribute locale to.
  #
  # source://liquid-4.0.3/lib/liquid/parse_context.rb:3
  def locale=(_arg0); end

  # Returns the value of attribute partial.
  #
  # source://liquid-4.0.3/lib/liquid/parse_context.rb:4
  def partial; end

  # source://liquid-4.0.3/lib/liquid/parse_context.rb:18
  def partial=(value); end

  # source://liquid-4.0.3/lib/liquid/parse_context.rb:25
  def partial_options; end

  # Returns the value of attribute trim_whitespace.
  #
  # source://liquid-4.0.3/lib/liquid/parse_context.rb:3
  def trim_whitespace; end

  # Sets the attribute trim_whitespace
  #
  # @param value the value to set the attribute trim_whitespace to.
  #
  # source://liquid-4.0.3/lib/liquid/parse_context.rb:3
  def trim_whitespace=(_arg0); end

  # Returns the value of attribute warnings.
  #
  # source://liquid-4.0.3/lib/liquid/parse_context.rb:4
  def warnings; end
end

# source://liquid-4.0.3/lib/liquid/parse_tree_visitor.rb:4
class Liquid::ParseTreeVisitor
  # @return [ParseTreeVisitor] a new instance of ParseTreeVisitor
  #
  # source://liquid-4.0.3/lib/liquid/parse_tree_visitor.rb:13
  def initialize(node, callbacks); end

  # source://liquid-4.0.3/lib/liquid/parse_tree_visitor.rb:18
  def add_callback_for(*classes, &block); end

  # source://liquid-4.0.3/lib/liquid/parse_tree_visitor.rb:26
  def visit(context = T.unsafe(nil)); end

  protected

  # source://liquid-4.0.3/lib/liquid/parse_tree_visitor.rb:38
  def children; end

  class << self
    # source://liquid-4.0.3/lib/liquid/parse_tree_visitor.rb:5
    def for(node, callbacks = T.unsafe(nil)); end
  end
end

# source://liquid-4.0.3/lib/liquid/parser.rb:2
class Liquid::Parser
  # @return [Parser] a new instance of Parser
  #
  # source://liquid-4.0.3/lib/liquid/parser.rb:3
  def initialize(input); end

  # source://liquid-4.0.3/lib/liquid/parser.rb:65
  def argument; end

  # source://liquid-4.0.3/lib/liquid/parser.rb:13
  def consume(type = T.unsafe(nil)); end

  # Only consumes the token if it matches the type
  # Returns the token's contents if it was consumed
  # or false otherwise.
  #
  # @return [Boolean]
  #
  # source://liquid-4.0.3/lib/liquid/parser.rb:25
  def consume?(type); end

  # source://liquid-4.0.3/lib/liquid/parser.rb:47
  def expression; end

  # Like consume? Except for an :id token of a certain name
  #
  # @return [Boolean]
  #
  # source://liquid-4.0.3/lib/liquid/parser.rb:33
  def id?(str); end

  # source://liquid-4.0.3/lib/liquid/parser.rb:9
  def jump(point); end

  # source://liquid-4.0.3/lib/liquid/parser.rb:41
  def look(type, ahead = T.unsafe(nil)); end

  # source://liquid-4.0.3/lib/liquid/parser.rb:76
  def variable_signature; end
end

# source://liquid-4.0.3/lib/liquid/parser_switching.rb:2
module Liquid::ParserSwitching
  # source://liquid-4.0.3/lib/liquid/parser_switching.rb:3
  def parse_with_selected_parser(markup); end

  private

  # source://liquid-4.0.3/lib/liquid/parser_switching.rb:27
  def markup_context(markup); end

  # source://liquid-4.0.3/lib/liquid/parser_switching.rb:19
  def strict_parse_with_error_context(markup); end
end

# source://liquid-4.0.3/lib/liquid.rb:39
Liquid::PartialTemplateParser = T.let(T.unsafe(nil), Regexp)

# source://liquid-4.0.3/lib/liquid.rb:36
Liquid::QuotedFragment = T.let(T.unsafe(nil), Regexp)

# source://liquid-4.0.3/lib/liquid.rb:35
Liquid::QuotedString = T.let(T.unsafe(nil), Regexp)

# source://liquid-4.0.3/lib/liquid/range_lookup.rb:2
class Liquid::RangeLookup
  # @return [RangeLookup] a new instance of RangeLookup
  #
  # source://liquid-4.0.3/lib/liquid/range_lookup.rb:13
  def initialize(start_obj, end_obj); end

  # source://liquid-4.0.3/lib/liquid/range_lookup.rb:18
  def evaluate(context); end

  private

  # source://liquid-4.0.3/lib/liquid/range_lookup.rb:26
  def to_integer(input); end

  class << self
    # source://liquid-4.0.3/lib/liquid/range_lookup.rb:3
    def parse(start_markup, end_markup); end
  end
end

# source://liquid-4.0.3/lib/liquid/tags/raw.rb:2
class Liquid::Raw < ::Liquid::Block
  # @return [Raw] a new instance of Raw
  #
  # source://liquid-4.0.3/lib/liquid/tags/raw.rb:6
  def initialize(tag_name, markup, parse_context); end

  # @return [Boolean]
  #
  # source://liquid-4.0.3/lib/liquid/tags/raw.rb:33
  def blank?; end

  # source://liquid-4.0.3/lib/liquid/tags/raw.rb:29
  def nodelist; end

  # @raise [SyntaxError]
  #
  # source://liquid-4.0.3/lib/liquid/tags/raw.rb:12
  def parse(tokens); end

  # source://liquid-4.0.3/lib/liquid/tags/raw.rb:25
  def render(_context); end

  protected

  # source://liquid-4.0.3/lib/liquid/tags/raw.rb:39
  def ensure_valid_markup(tag_name, markup, parse_context); end
end

# source://liquid-4.0.3/lib/liquid/tags/raw.rb:4
Liquid::Raw::FullTokenPossiblyInvalid = T.let(T.unsafe(nil), Regexp)

# source://liquid-4.0.3/lib/liquid/tags/raw.rb:3
Liquid::Raw::Syntax = T.let(T.unsafe(nil), Regexp)

# source://liquid-4.0.3/lib/liquid/resource_limits.rb:2
class Liquid::ResourceLimits
  # @return [ResourceLimits] a new instance of ResourceLimits
  #
  # source://liquid-4.0.3/lib/liquid/resource_limits.rb:6
  def initialize(limits); end

  # Returns the value of attribute assign_score.
  #
  # source://liquid-4.0.3/lib/liquid/resource_limits.rb:3
  def assign_score; end

  # Sets the attribute assign_score
  #
  # @param value the value to set the attribute assign_score to.
  #
  # source://liquid-4.0.3/lib/liquid/resource_limits.rb:3
  def assign_score=(_arg0); end

  # Returns the value of attribute assign_score_limit.
  #
  # source://liquid-4.0.3/lib/liquid/resource_limits.rb:3
  def assign_score_limit; end

  # Sets the attribute assign_score_limit
  #
  # @param value the value to set the attribute assign_score_limit to.
  #
  # source://liquid-4.0.3/lib/liquid/resource_limits.rb:3
  def assign_score_limit=(_arg0); end

  # @return [Boolean]
  #
  # source://liquid-4.0.3/lib/liquid/resource_limits.rb:13
  def reached?; end

  # Returns the value of attribute render_length.
  #
  # source://liquid-4.0.3/lib/liquid/resource_limits.rb:3
  def render_length; end

  # Sets the attribute render_length
  #
  # @param value the value to set the attribute render_length to.
  #
  # source://liquid-4.0.3/lib/liquid/resource_limits.rb:3
  def render_length=(_arg0); end

  # Returns the value of attribute render_length_limit.
  #
  # source://liquid-4.0.3/lib/liquid/resource_limits.rb:3
  def render_length_limit; end

  # Sets the attribute render_length_limit
  #
  # @param value the value to set the attribute render_length_limit to.
  #
  # source://liquid-4.0.3/lib/liquid/resource_limits.rb:3
  def render_length_limit=(_arg0); end

  # Returns the value of attribute render_score.
  #
  # source://liquid-4.0.3/lib/liquid/resource_limits.rb:3
  def render_score; end

  # Sets the attribute render_score
  #
  # @param value the value to set the attribute render_score to.
  #
  # source://liquid-4.0.3/lib/liquid/resource_limits.rb:3
  def render_score=(_arg0); end

  # Returns the value of attribute render_score_limit.
  #
  # source://liquid-4.0.3/lib/liquid/resource_limits.rb:3
  def render_score_limit; end

  # Sets the attribute render_score_limit
  #
  # @param value the value to set the attribute render_score_limit to.
  #
  # source://liquid-4.0.3/lib/liquid/resource_limits.rb:3
  def render_score_limit=(_arg0); end

  # source://liquid-4.0.3/lib/liquid/resource_limits.rb:19
  def reset; end
end

# source://liquid-4.0.3/lib/liquid/errors.rb:46
class Liquid::StackLevelError < ::Liquid::Error; end

# source://liquid-4.0.3/lib/liquid/errors.rb:44
class Liquid::StandardError < ::Liquid::Error; end

# source://liquid-4.0.3/lib/liquid/standardfilters.rb:5
module Liquid::StandardFilters
  # absolute value
  #
  # source://liquid-4.0.3/lib/liquid/standardfilters.rb:352
  def abs(input); end

  # add one string to another
  #
  # source://liquid-4.0.3/lib/liquid/standardfilters.rb:273
  def append(input, string); end

  # source://liquid-4.0.3/lib/liquid/standardfilters.rb:406
  def at_least(input, n); end

  # source://liquid-4.0.3/lib/liquid/standardfilters.rb:414
  def at_most(input, n); end

  # capitalize words in the input centence
  #
  # source://liquid-4.0.3/lib/liquid/standardfilters.rb:37
  def capitalize(input); end

  # source://liquid-4.0.3/lib/liquid/standardfilters.rb:394
  def ceil(input); end

  # Remove nils within an array
  # provide optional property with which to check for nil
  #
  # source://liquid-4.0.3/lib/liquid/standardfilters.rb:236
  def compact(input, property = T.unsafe(nil)); end

  # source://liquid-4.0.3/lib/liquid/standardfilters.rb:277
  def concat(input, array); end

  # Reformat a date using Ruby's core Time#strftime( string ) -> string
  #
  #   %a - The abbreviated weekday name (``Sun'')
  #   %A - The  full  weekday  name (``Sunday'')
  #   %b - The abbreviated month name (``Jan'')
  #   %B - The  full  month  name (``January'')
  #   %c - The preferred local date and time representation
  #   %d - Day of the month (01..31)
  #   %H - Hour of the day, 24-hour clock (00..23)
  #   %I - Hour of the day, 12-hour clock (01..12)
  #   %j - Day of the year (001..366)
  #   %m - Month of the year (01..12)
  #   %M - Minute of the hour (00..59)
  #   %p - Meridian indicator (``AM''  or  ``PM'')
  #   %s - Number of seconds since 1970-01-01 00:00:00 UTC.
  #   %S - Second of the minute (00..60)
  #   %U - Week  number  of the current year,
  #           starting with the first Sunday as the first
  #           day of the first week (00..53)
  #   %W - Week  number  of the current year,
  #           starting with the first Monday as the first
  #           day of the first week (00..53)
  #   %w - Day of the week (Sunday is 0, 0..6)
  #   %x - Preferred representation for the date alone, no time
  #   %X - Preferred representation for the time alone, no date
  #   %y - Year without a century (00..99)
  #   %Y - Year with century
  #   %Z - Time zone name
  #   %% - Literal ``%'' character
  #
  #   See also: http://www.ruby-doc.org/core/Time.html#method-i-strftime
  #
  # source://liquid-4.0.3/lib/liquid/standardfilters.rb:325
  def date(input, format); end

  # source://liquid-4.0.3/lib/liquid/standardfilters.rb:422
  def default(input, default_value = T.unsafe(nil)); end

  # division
  #
  # source://liquid-4.0.3/lib/liquid/standardfilters.rb:373
  def divided_by(input, operand); end

  # convert an input string to DOWNCASE
  #
  # source://liquid-4.0.3/lib/liquid/standardfilters.rb:27
  def downcase(input); end

  # source://liquid-4.0.3/lib/liquid/standardfilters.rb:41
  def escape(input); end

  # source://liquid-4.0.3/lib/liquid/standardfilters.rb:46
  def escape_once(input); end

  # Get the first element of the passed in array
  #
  # Example:
  #    {{ product.images | first | to_img }}
  #
  # source://liquid-4.0.3/lib/liquid/standardfilters.rb:338
  def first(array); end

  # source://liquid-4.0.3/lib/liquid/standardfilters.rb:400
  def floor(input); end

  # source://liquid-4.0.3/lib/liquid/standardfilters.rb:41
  def h(input); end

  # Join elements of the array with certain character between them
  #
  # source://liquid-4.0.3/lib/liquid/standardfilters.rb:128
  def join(input, glue = T.unsafe(nil)); end

  # Get the last element of the passed in array
  #
  # Example:
  #    {{ product.images | last | to_img }}
  #
  # source://liquid-4.0.3/lib/liquid/standardfilters.rb:347
  def last(array); end

  # source://liquid-4.0.3/lib/liquid/standardfilters.rb:107
  def lstrip(input); end

  # map/collect on a given property
  #
  # source://liquid-4.0.3/lib/liquid/standardfilters.rb:219
  def map(input, property); end

  # subtraction
  #
  # source://liquid-4.0.3/lib/liquid/standardfilters.rb:363
  def minus(input, operand); end

  # source://liquid-4.0.3/lib/liquid/standardfilters.rb:379
  def modulo(input, operand); end

  # Add <br /> tags in front of all newlines in input string
  #
  # source://liquid-4.0.3/lib/liquid/standardfilters.rb:290
  def newline_to_br(input); end

  # addition
  #
  # source://liquid-4.0.3/lib/liquid/standardfilters.rb:358
  def plus(input, operand); end

  # prepend a string to another
  #
  # source://liquid-4.0.3/lib/liquid/standardfilters.rb:285
  def prepend(input, string); end

  # remove a substring
  #
  # source://liquid-4.0.3/lib/liquid/standardfilters.rb:263
  def remove(input, string); end

  # remove the first occurrences of a substring
  #
  # source://liquid-4.0.3/lib/liquid/standardfilters.rb:268
  def remove_first(input, string); end

  # Replace occurrences of a string with another
  #
  # source://liquid-4.0.3/lib/liquid/standardfilters.rb:253
  def replace(input, string, replacement = T.unsafe(nil)); end

  # Replace the first occurrences of a string with another
  #
  # source://liquid-4.0.3/lib/liquid/standardfilters.rb:258
  def replace_first(input, string, replacement = T.unsafe(nil)); end

  # Reverse the elements of an array
  #
  # source://liquid-4.0.3/lib/liquid/standardfilters.rb:213
  def reverse(input); end

  # source://liquid-4.0.3/lib/liquid/standardfilters.rb:385
  def round(input, n = T.unsafe(nil)); end

  # source://liquid-4.0.3/lib/liquid/standardfilters.rb:111
  def rstrip(input); end

  # Return the size of an array or of an string
  #
  # source://liquid-4.0.3/lib/liquid/standardfilters.rb:22
  def size(input); end

  # source://liquid-4.0.3/lib/liquid/standardfilters.rb:63
  def slice(input, offset, length = T.unsafe(nil)); end

  # Sort elements of the array
  # provide optional property with which to sort an array of hashes or drops
  #
  # source://liquid-4.0.3/lib/liquid/standardfilters.rb:134
  def sort(input, property = T.unsafe(nil)); end

  # Sort elements of an array ignoring case if strings
  # provide optional property with which to sort an array of hashes or drops
  #
  # source://liquid-4.0.3/lib/liquid/standardfilters.rb:154
  def sort_natural(input, property = T.unsafe(nil)); end

  # Split input string into an array of substrings separated by given pattern.
  #
  # Example:
  #   <div class="summary">{{ post | split '//' | first }}</div>
  #
  # source://liquid-4.0.3/lib/liquid/standardfilters.rb:99
  def split(input, pattern); end

  # source://liquid-4.0.3/lib/liquid/standardfilters.rb:103
  def strip(input); end

  # source://liquid-4.0.3/lib/liquid/standardfilters.rb:115
  def strip_html(input); end

  # Remove all newlines from the string
  #
  # source://liquid-4.0.3/lib/liquid/standardfilters.rb:123
  def strip_newlines(input); end

  # multiplication
  #
  # source://liquid-4.0.3/lib/liquid/standardfilters.rb:368
  def times(input, operand); end

  # Truncate a string down to x characters
  #
  # source://liquid-4.0.3/lib/liquid/standardfilters.rb:75
  def truncate(input, length = T.unsafe(nil), truncate_string = T.unsafe(nil)); end

  # source://liquid-4.0.3/lib/liquid/standardfilters.rb:85
  def truncatewords(input, words = T.unsafe(nil), truncate_string = T.unsafe(nil)); end

  # Remove duplicate elements from an array
  # provide optional property with which to determine uniqueness
  #
  # source://liquid-4.0.3/lib/liquid/standardfilters.rb:196
  def uniq(input, property = T.unsafe(nil)); end

  # convert an input string to UPCASE
  #
  # source://liquid-4.0.3/lib/liquid/standardfilters.rb:32
  def upcase(input); end

  # @raise [Liquid::ArgumentError]
  #
  # source://liquid-4.0.3/lib/liquid/standardfilters.rb:54
  def url_decode(input); end

  # source://liquid-4.0.3/lib/liquid/standardfilters.rb:50
  def url_encode(input); end

  # Filter the elements of an array to those with a certain property value.
  # By default the target is any truthy value.
  #
  # source://liquid-4.0.3/lib/liquid/standardfilters.rb:174
  def where(input, property, target_value = T.unsafe(nil)); end

  private

  # source://liquid-4.0.3/lib/liquid/standardfilters.rb:436
  def apply_operation(input, operand, operation); end

  # source://liquid-4.0.3/lib/liquid/standardfilters.rb:449
  def nil_safe_casecmp(a, b); end

  # source://liquid-4.0.3/lib/liquid/standardfilters.rb:441
  def nil_safe_compare(a, b); end

  # @raise [Liquid::ArgumentError]
  #
  # source://liquid-4.0.3/lib/liquid/standardfilters.rb:432
  def raise_property_error(property); end
end

# source://liquid-4.0.3/lib/liquid/standardfilters.rb:6
Liquid::StandardFilters::HTML_ESCAPE = T.let(T.unsafe(nil), Hash)

# source://liquid-4.0.3/lib/liquid/standardfilters.rb:13
Liquid::StandardFilters::HTML_ESCAPE_ONCE_REGEXP = T.let(T.unsafe(nil), Regexp)

# source://liquid-4.0.3/lib/liquid/standardfilters.rb:457
class Liquid::StandardFilters::InputIterator
  include ::Enumerable

  # @return [InputIterator] a new instance of InputIterator
  #
  # source://liquid-4.0.3/lib/liquid/standardfilters.rb:460
  def initialize(input); end

  # source://liquid-4.0.3/lib/liquid/standardfilters.rb:488
  def compact; end

  # source://liquid-4.0.3/lib/liquid/standardfilters.rb:476
  def concat(args); end

  # source://liquid-4.0.3/lib/liquid/standardfilters.rb:497
  def each; end

  # @return [Boolean]
  #
  # source://liquid-4.0.3/lib/liquid/standardfilters.rb:492
  def empty?; end

  # source://liquid-4.0.3/lib/liquid/standardfilters.rb:472
  def join(glue); end

  # source://liquid-4.0.3/lib/liquid/standardfilters.rb:480
  def reverse; end

  # source://liquid-4.0.3/lib/liquid/standardfilters.rb:484
  def uniq(&block); end
end

# source://liquid-4.0.3/lib/liquid/standardfilters.rb:14
Liquid::StandardFilters::STRIP_HTML_BLOCKS = T.let(T.unsafe(nil), Regexp)

# source://liquid-4.0.3/lib/liquid/standardfilters.rb:19
Liquid::StandardFilters::STRIP_HTML_TAGS = T.let(T.unsafe(nil), Regexp)

# Strainer is the parent class for the filters system.
# New filters are mixed into the strainer class which is then instantiated for each liquid template render run.
#
# The Strainer only allows method calls defined in filters given to it via Strainer.global_filter,
# Context#add_filters or Template.register_filter
#
# source://liquid-4.0.3/lib/liquid/strainer.rb:9
class Liquid::Strainer
  # @return [Strainer] a new instance of Strainer
  #
  # source://liquid-4.0.3/lib/liquid/strainer.rb:20
  def initialize(context); end

  # source://liquid-4.0.3/lib/liquid/strainer.rb:54
  def invoke(method, *args); end

  class << self
    # @raise [ArgumentError]
    #
    # source://liquid-4.0.3/lib/liquid/strainer.rb:28
    def add_filter(filter); end

    # source://liquid-4.0.3/lib/liquid/strainer.rb:50
    def create(context, filters = T.unsafe(nil)); end

    # Returns the value of attribute filter_methods.
    #
    # source://liquid-4.0.3/lib/liquid/strainer.rb:25
    def filter_methods; end

    # source://liquid-4.0.3/lib/liquid/strainer.rb:41
    def global_filter(filter); end

    # @return [Boolean]
    #
    # source://liquid-4.0.3/lib/liquid/strainer.rb:46
    def invokable?(method); end
  end
end

# source://liquid-4.0.3/lib/liquid/errors.rb:45
class Liquid::SyntaxError < ::Liquid::Error; end

# source://liquid-4.0.3/lib/liquid/tags/table_row.rb:2
class Liquid::TableRow < ::Liquid::Block
  # @return [TableRow] a new instance of TableRow
  #
  # source://liquid-4.0.3/lib/liquid/tags/table_row.rb:7
  def initialize(tag_name, markup, options); end

  # Returns the value of attribute attributes.
  #
  # source://liquid-4.0.3/lib/liquid/tags/table_row.rb:5
  def attributes; end

  # Returns the value of attribute collection_name.
  #
  # source://liquid-4.0.3/lib/liquid/tags/table_row.rb:5
  def collection_name; end

  # source://liquid-4.0.3/lib/liquid/tags/table_row.rb:21
  def render(context); end

  # Returns the value of attribute variable_name.
  #
  # source://liquid-4.0.3/lib/liquid/tags/table_row.rb:5
  def variable_name; end
end

# source://liquid-4.0.3/lib/liquid/tags/table_row.rb:54
class Liquid::TableRow::ParseTreeVisitor < ::Liquid::ParseTreeVisitor
  # source://liquid-4.0.3/lib/liquid/tags/table_row.rb:55
  def children; end
end

# source://liquid-4.0.3/lib/liquid/tags/table_row.rb:3
Liquid::TableRow::Syntax = T.let(T.unsafe(nil), Regexp)

# source://liquid-4.0.3/lib/liquid/tablerowloop_drop.rb:2
class Liquid::TablerowloopDrop < ::Liquid::Drop
  # @return [TablerowloopDrop] a new instance of TablerowloopDrop
  #
  # source://liquid-4.0.3/lib/liquid/tablerowloop_drop.rb:3
  def initialize(length, cols); end

  # Returns the value of attribute col.
  #
  # source://liquid-4.0.3/lib/liquid/tablerowloop_drop.rb:11
  def col; end

  # source://liquid-4.0.3/lib/liquid/tablerowloop_drop.rb:21
  def col0; end

  # source://liquid-4.0.3/lib/liquid/tablerowloop_drop.rb:41
  def col_first; end

  # source://liquid-4.0.3/lib/liquid/tablerowloop_drop.rb:45
  def col_last; end

  # source://liquid-4.0.3/lib/liquid/tablerowloop_drop.rb:33
  def first; end

  # source://liquid-4.0.3/lib/liquid/tablerowloop_drop.rb:13
  def index; end

  # source://liquid-4.0.3/lib/liquid/tablerowloop_drop.rb:17
  def index0; end

  # source://liquid-4.0.3/lib/liquid/tablerowloop_drop.rb:37
  def last; end

  # Returns the value of attribute length.
  #
  # source://liquid-4.0.3/lib/liquid/tablerowloop_drop.rb:11
  def length; end

  # source://liquid-4.0.3/lib/liquid/tablerowloop_drop.rb:25
  def rindex; end

  # source://liquid-4.0.3/lib/liquid/tablerowloop_drop.rb:29
  def rindex0; end

  # Returns the value of attribute row.
  #
  # source://liquid-4.0.3/lib/liquid/tablerowloop_drop.rb:11
  def row; end

  protected

  # source://liquid-4.0.3/lib/liquid/tablerowloop_drop.rb:51
  def increment!; end
end

# source://liquid-4.0.3/lib/liquid/tag.rb:2
class Liquid::Tag
  include ::Liquid::ParserSwitching

  # @return [Tag] a new instance of Tag
  #
  # source://liquid-4.0.3/lib/liquid/tag.rb:17
  def initialize(tag_name, markup, parse_context); end

  # @return [Boolean]
  #
  # source://liquid-4.0.3/lib/liquid/tag.rb:39
  def blank?; end

  # Returns the value of attribute line_number.
  #
  # source://liquid-4.0.3/lib/liquid/tag.rb:3
  def line_number; end

  # source://liquid-4.0.3/lib/liquid/tag.rb:31
  def name; end

  # Returns the value of attribute nodelist.
  #
  # source://liquid-4.0.3/lib/liquid/tag.rb:3
  def nodelist; end

  # Returns the value of attribute parse_context.
  #
  # source://liquid-4.0.3/lib/liquid/tag.rb:3
  def options; end

  # source://liquid-4.0.3/lib/liquid/tag.rb:24
  def parse(_tokens); end

  # Returns the value of attribute parse_context.
  #
  # source://liquid-4.0.3/lib/liquid/tag.rb:3
  def parse_context; end

  # source://liquid-4.0.3/lib/liquid/tag.rb:27
  def raw; end

  # source://liquid-4.0.3/lib/liquid/tag.rb:35
  def render(_context); end

  # Returns the value of attribute tag_name.
  #
  # source://liquid-4.0.3/lib/liquid/tag.rb:3
  def tag_name; end

  class << self
    # source://liquid-4.0.3/lib/liquid/tag.rb:8
    def parse(tag_name, markup, tokenizer, options); end
  end
end

# source://liquid-4.0.3/lib/liquid.rb:37
Liquid::TagAttributes = T.let(T.unsafe(nil), Regexp)

# source://liquid-4.0.3/lib/liquid.rb:29
Liquid::TagEnd = T.let(T.unsafe(nil), Regexp)

# source://liquid-4.0.3/lib/liquid.rb:28
Liquid::TagStart = T.let(T.unsafe(nil), Regexp)

# source://liquid-4.0.3/lib/liquid/errors.rb:47
class Liquid::TaintedError < ::Liquid::Error; end

# Templates are central to liquid.
# Interpretating templates is a two step process. First you compile the
# source code you got. During compile time some extensive error checking is performed.
# your code should expect to get some SyntaxErrors.
#
# After you have a compiled template you can then <tt>render</tt> it.
# You can use a compiled template over and over again and keep it cached.
#
# Example:
#
#   template = Liquid::Template.parse(source)
#   template.render('user_name' => 'bob')
#
# source://liquid-4.0.3/lib/liquid/template.rb:15
class Liquid::Template
  # @return [Template] a new instance of Template
  #
  # source://liquid-4.0.3/lib/liquid/template.rb:120
  def initialize; end

  # source://liquid-4.0.3/lib/liquid/template.rb:141
  def assigns; end

  # source://liquid-4.0.3/lib/liquid/template.rb:149
  def errors; end

  # source://liquid-4.0.3/lib/liquid/template.rb:145
  def instance_assigns; end

  # Parse source code.
  # Returns self for easy chaining
  #
  # source://liquid-4.0.3/lib/liquid/template.rb:127
  def parse(source, options = T.unsafe(nil)); end

  # Returns the value of attribute profiler.
  #
  # source://liquid-4.0.3/lib/liquid/template.rb:57
  def profiler; end

  # source://liquid-4.0.3/lib/liquid/template.rb:137
  def registers; end

  # Render takes a hash with local variables.
  #
  # if you use the same filters over and over again consider registering them globally
  # with <tt>Template.register_filter</tt>
  #
  # if profiling was enabled in <tt>Template#parse</tt> then the resulting profiling information
  # will be available via <tt>Template#profiler</tt>
  #
  # Following options can be passed:
  #
  #  * <tt>filters</tt> : array with local filters
  #  * <tt>registers</tt> : hash with register variables. Those can be accessed from
  #    filters and tags and might be useful to integrate liquid more with its host application
  #
  # source://liquid-4.0.3/lib/liquid/template.rb:167
  def render(*args); end

  # source://liquid-4.0.3/lib/liquid/template.rb:218
  def render!(*args); end

  # Returns the value of attribute resource_limits.
  #
  # source://liquid-4.0.3/lib/liquid/template.rb:17
  def resource_limits; end

  # Returns the value of attribute root.
  #
  # source://liquid-4.0.3/lib/liquid/template.rb:16
  def root; end

  # Sets the attribute root
  #
  # @param value the value to set the attribute root to.
  #
  # source://liquid-4.0.3/lib/liquid/template.rb:16
  def root=(_arg0); end

  # Returns the value of attribute warnings.
  #
  # source://liquid-4.0.3/lib/liquid/template.rb:17
  def warnings; end

  private

  # source://liquid-4.0.3/lib/liquid/template.rb:246
  def apply_options_to_context(context, options); end

  # source://liquid-4.0.3/lib/liquid/template.rb:225
  def tokenize(source); end

  # source://liquid-4.0.3/lib/liquid/template.rb:229
  def with_profiling(context); end

  class << self
    # Returns the value of attribute default_exception_renderer.
    #
    # source://liquid-4.0.3/lib/liquid/template.rb:72
    def default_exception_renderer; end

    # Sets the attribute default_exception_renderer
    #
    # @param value the value to set the attribute default_exception_renderer to.
    #
    # source://liquid-4.0.3/lib/liquid/template.rb:72
    def default_exception_renderer=(_arg0); end

    # source://liquid-4.0.3/lib/liquid/template.rb:107
    def default_resource_limits; end

    # source://liquid-4.0.3/lib/liquid/template.rb:93
    def error_mode; end

    # Sets how strict the parser should be.
    # :lax acts like liquid 2.5 and silently ignores malformed tags in most cases.
    # :warn is the default and will give deprecation warnings when invalid syntax is used.
    # :strict will enforce correct syntax.
    #
    # source://liquid-4.0.3/lib/liquid/template.rb:64
    def error_mode=(_arg0); end

    # source://liquid-4.0.3/lib/liquid/template.rb:77
    def file_system; end

    # source://liquid-4.0.3/lib/liquid/template.rb:81
    def file_system=(obj); end

    # creates a new <tt>Template</tt> object from liquid source code
    # To enable profiling, pass in <tt>profile: true</tt> as an option.
    # See Liquid::Profiler for more information
    #
    # source://liquid-4.0.3/lib/liquid/template.rb:114
    def parse(source, options = T.unsafe(nil)); end

    # Pass a module with filter methods which should be available
    # to all liquid views. Good for registering the standard library
    #
    # source://liquid-4.0.3/lib/liquid/template.rb:103
    def register_filter(mod); end

    # source://liquid-4.0.3/lib/liquid/template.rb:85
    def register_tag(name, klass); end

    # source://liquid-4.0.3/lib/liquid/template.rb:89
    def tags; end

    # source://liquid-4.0.3/lib/liquid/template.rb:97
    def taint_mode; end

    # Sets how strict the taint checker should be.
    # :lax is the default, and ignores the taint flag completely
    # :warn adds a warning, but does not interrupt the rendering
    # :error raises an error when tainted output is used
    #
    # source://liquid-4.0.3/lib/liquid/template.rb:70
    def taint_mode=(_arg0); end
  end
end

# source://liquid-4.0.3/lib/liquid/template.rb:21
class Liquid::Template::TagRegistry
  include ::Enumerable

  # @return [TagRegistry] a new instance of TagRegistry
  #
  # source://liquid-4.0.3/lib/liquid/template.rb:24
  def initialize; end

  # source://liquid-4.0.3/lib/liquid/template.rb:29
  def [](tag_name); end

  # source://liquid-4.0.3/lib/liquid/template.rb:36
  def []=(tag_name, klass); end

  # source://liquid-4.0.3/lib/liquid/template.rb:41
  def delete(tag_name); end

  # source://liquid-4.0.3/lib/liquid/template.rb:46
  def each(&block); end

  private

  # source://liquid-4.0.3/lib/liquid/template.rb:52
  def lookup_class(name); end
end

# source://liquid-4.0.3/lib/liquid.rb:40
Liquid::TemplateParser = T.let(T.unsafe(nil), Regexp)

# source://liquid-4.0.3/lib/liquid/tokenizer.rb:2
class Liquid::Tokenizer
  # @return [Tokenizer] a new instance of Tokenizer
  #
  # source://liquid-4.0.3/lib/liquid/tokenizer.rb:5
  def initialize(source, line_numbers = T.unsafe(nil)); end

  # Returns the value of attribute line_number.
  #
  # source://liquid-4.0.3/lib/liquid/tokenizer.rb:3
  def line_number; end

  # source://liquid-4.0.3/lib/liquid/tokenizer.rb:11
  def shift; end

  private

  # source://liquid-4.0.3/lib/liquid/tokenizer.rb:19
  def tokenize; end
end

# source://liquid-4.0.3/lib/liquid/errors.rb:52
class Liquid::UndefinedDropMethod < ::Liquid::Error; end

# source://liquid-4.0.3/lib/liquid/errors.rb:53
class Liquid::UndefinedFilter < ::Liquid::Error; end

# source://liquid-4.0.3/lib/liquid/errors.rb:51
class Liquid::UndefinedVariable < ::Liquid::Error; end

# Unless is a conditional just like 'if' but works on the inverse logic.
#
#   {% unless x < 0 %} x is greater than zero {% endunless %}
#
# source://liquid-4.0.3/lib/liquid/tags/unless.rb:8
class Liquid::Unless < ::Liquid::If
  # source://liquid-4.0.3/lib/liquid/tags/unless.rb:9
  def render(context); end
end

# source://liquid-4.0.3/lib/liquid/utils.rb:2
module Liquid::Utils
  class << self
    # source://liquid-4.0.3/lib/liquid/utils.rb:3
    def slice_collection(collection, from, to); end

    # source://liquid-4.0.3/lib/liquid/utils.rb:11
    def slice_collection_using_each(collection, from, to); end

    # source://liquid-4.0.3/lib/liquid/utils.rb:63
    def to_date(obj); end

    # source://liquid-4.0.3/lib/liquid/utils.rb:36
    def to_integer(num); end

    # source://liquid-4.0.3/lib/liquid/utils.rb:46
    def to_number(obj); end
  end
end

# source://liquid-4.0.3/lib/liquid/version.rb:4
Liquid::VERSION = T.let(T.unsafe(nil), String)

# Holds variables. Variables are only loaded "just in time"
# and are not evaluated as part of the render stage
#
#   {{ monkey }}
#   {{ user.name }}
#
# Variables can be combined with filters:
#
#   {{ user | link }}
#
# source://liquid-4.0.3/lib/liquid/variable.rb:12
class Liquid::Variable
  include ::Liquid::ParserSwitching

  # @return [Variable] a new instance of Variable
  #
  # source://liquid-4.0.3/lib/liquid/variable.rb:25
  def initialize(markup, parse_context); end

  # Returns the value of attribute filters.
  #
  # source://liquid-4.0.3/lib/liquid/variable.rb:19
  def filters; end

  # Sets the attribute filters
  #
  # @param value the value to set the attribute filters to.
  #
  # source://liquid-4.0.3/lib/liquid/variable.rb:19
  def filters=(_arg0); end

  # source://liquid-4.0.3/lib/liquid/variable.rb:42
  def lax_parse(markup); end

  # Returns the value of attribute line_number.
  #
  # source://liquid-4.0.3/lib/liquid/variable.rb:19
  def line_number; end

  # Sets the attribute line_number
  #
  # @param value the value to set the attribute line_number to.
  #
  # source://liquid-4.0.3/lib/liquid/variable.rb:19
  def line_number=(_arg0); end

  # source://liquid-4.0.3/lib/liquid/variable.rb:38
  def markup_context(markup); end

  # Returns the value of attribute name.
  #
  # source://liquid-4.0.3/lib/liquid/variable.rb:19
  def name; end

  # Sets the attribute name
  #
  # @param value the value to set the attribute name to.
  #
  # source://liquid-4.0.3/lib/liquid/variable.rb:19
  def name=(_arg0); end

  # Returns the value of attribute parse_context.
  #
  # source://liquid-4.0.3/lib/liquid/variable.rb:20
  def options; end

  # Returns the value of attribute parse_context.
  #
  # source://liquid-4.0.3/lib/liquid/variable.rb:20
  def parse_context; end

  # source://liquid-4.0.3/lib/liquid/variable.rb:73
  def parse_filterargs(p); end

  # source://liquid-4.0.3/lib/liquid/variable.rb:34
  def raw; end

  # source://liquid-4.0.3/lib/liquid/variable.rb:81
  def render(context); end

  # source://liquid-4.0.3/lib/liquid/variable.rb:60
  def strict_parse(markup); end

  private

  # source://liquid-4.0.3/lib/liquid/variable.rb:111
  def evaluate_filter_expressions(context, filter_args, filter_kwargs); end

  # source://liquid-4.0.3/lib/liquid/variable.rb:96
  def parse_filter_expressions(filter_name, unparsed_args); end

  # source://liquid-4.0.3/lib/liquid/variable.rb:123
  def taint_check(context, obj); end
end

# source://liquid-4.0.3/lib/liquid/variable.rb:15
Liquid::Variable::FilterArgsRegex = T.let(T.unsafe(nil), Regexp)

# source://liquid-4.0.3/lib/liquid/variable.rb:13
Liquid::Variable::FilterMarkupRegex = T.let(T.unsafe(nil), Regexp)

# source://liquid-4.0.3/lib/liquid/variable.rb:14
Liquid::Variable::FilterParser = T.let(T.unsafe(nil), Regexp)

# source://liquid-4.0.3/lib/liquid/variable.rb:16
Liquid::Variable::JustTagAttributes = T.let(T.unsafe(nil), Regexp)

# source://liquid-4.0.3/lib/liquid/variable.rb:17
Liquid::Variable::MarkupWithQuotedFragment = T.let(T.unsafe(nil), Regexp)

# source://liquid-4.0.3/lib/liquid/variable.rb:142
class Liquid::Variable::ParseTreeVisitor < ::Liquid::ParseTreeVisitor
  # source://liquid-4.0.3/lib/liquid/variable.rb:143
  def children; end
end

# source://liquid-4.0.3/lib/liquid.rb:26
Liquid::VariableAttributeSeparator = T.let(T.unsafe(nil), String)

# source://liquid-4.0.3/lib/liquid.rb:33
Liquid::VariableEnd = T.let(T.unsafe(nil), Regexp)

# source://liquid-4.0.3/lib/liquid.rb:34
Liquid::VariableIncompleteEnd = T.let(T.unsafe(nil), Regexp)

# source://liquid-4.0.3/lib/liquid/variable_lookup.rb:2
class Liquid::VariableLookup
  # @return [VariableLookup] a new instance of VariableLookup
  #
  # source://liquid-4.0.3/lib/liquid/variable_lookup.rb:12
  def initialize(markup); end

  # source://liquid-4.0.3/lib/liquid/variable_lookup.rb:72
  def ==(other); end

  # source://liquid-4.0.3/lib/liquid/variable_lookup.rb:34
  def evaluate(context); end

  # Returns the value of attribute lookups.
  #
  # source://liquid-4.0.3/lib/liquid/variable_lookup.rb:6
  def lookups; end

  # Returns the value of attribute name.
  #
  # source://liquid-4.0.3/lib/liquid/variable_lookup.rb:6
  def name; end

  protected

  # source://liquid-4.0.3/lib/liquid/variable_lookup.rb:78
  def state; end

  class << self
    # source://liquid-4.0.3/lib/liquid/variable_lookup.rb:8
    def parse(markup); end
  end
end

# source://liquid-4.0.3/lib/liquid/variable_lookup.rb:4
Liquid::VariableLookup::COMMAND_METHODS = T.let(T.unsafe(nil), Array)

# source://liquid-4.0.3/lib/liquid/variable_lookup.rb:82
class Liquid::VariableLookup::ParseTreeVisitor < ::Liquid::ParseTreeVisitor
  # source://liquid-4.0.3/lib/liquid/variable_lookup.rb:83
  def children; end
end

# source://liquid-4.0.3/lib/liquid/variable_lookup.rb:3
Liquid::VariableLookup::SQUARE_BRACKETED = T.let(T.unsafe(nil), Regexp)

# source://liquid-4.0.3/lib/liquid.rb:41
Liquid::VariableParser = T.let(T.unsafe(nil), Regexp)

# source://liquid-4.0.3/lib/liquid.rb:31
Liquid::VariableSegment = T.let(T.unsafe(nil), Regexp)

# source://liquid-4.0.3/lib/liquid.rb:30
Liquid::VariableSignature = T.let(T.unsafe(nil), Regexp)

# source://liquid-4.0.3/lib/liquid.rb:32
Liquid::VariableStart = T.let(T.unsafe(nil), Regexp)

# source://liquid-4.0.3/lib/liquid.rb:27
Liquid::WhitespaceControl = T.let(T.unsafe(nil), String)

# source://liquid-4.0.3/lib/liquid/errors.rb:49
class Liquid::ZeroDivisionError < ::Liquid::Error; end

# source://liquid-4.0.3/lib/liquid/extensions.rb:70
class NilClass
  # source://liquid-4.0.3/lib/liquid/extensions.rb:71
  def to_liquid; end
end

# source://liquid-4.0.3/lib/liquid/extensions.rb:28
class Numeric
  include ::Comparable

  # source://liquid-4.0.3/lib/liquid/extensions.rb:29
  def to_liquid; end
end

# source://liquid-4.0.3/lib/liquid/extensions.rb:34
class Range
  include ::Enumerable

  # source://liquid-4.0.3/lib/liquid/extensions.rb:35
  def to_liquid; end
end

# source://liquid-4.0.3/lib/liquid/extensions.rb:4
class String
  include ::Comparable

  # source://liquid-4.0.3/lib/liquid/extensions.rb:5
  def to_liquid; end
end

# source://activesupport-7.0.3.1/lib/active_support/core_ext/object/blank.rb:104
String::BLANK_RE = T.let(T.unsafe(nil), Regexp)

# source://activesupport-7.0.3.1/lib/active_support/core_ext/object/blank.rb:105
String::ENCODED_BLANKS = T.let(T.unsafe(nil), Concurrent::Map)

# source://liquid-4.0.3/lib/liquid/extensions.rb:10
class Symbol
  include ::Comparable

  # source://liquid-4.0.3/lib/liquid/extensions.rb:11
  def to_liquid; end
end

# source://liquid-4.0.3/lib/liquid/extensions.rb:40
class Time
  include ::Comparable

  # source://liquid-4.0.3/lib/liquid/extensions.rb:41
  def to_liquid; end
end

# source://activesupport-7.0.3.1/lib/active_support/core_ext/time/conversions.rb:8
Time::DATE_FORMATS = T.let(T.unsafe(nil), Hash)

# source://liquid-4.0.3/lib/liquid/extensions.rb:58
class TrueClass
  # source://liquid-4.0.3/lib/liquid/extensions.rb:59
  def to_liquid; end
end
